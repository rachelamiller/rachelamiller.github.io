<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real or Fake Headline Runner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d0d1e; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            pointer-events: none; /* Allows clicks to pass through */
        }
        #message-box {
            background-color: rgba(0, 0, 0, 0.75);
            padding: 30px 40px;
            border-radius: 15px;
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            pointer-events: auto;
            max-width: 90%;
        }
        #headline-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffcc00; /* Yellow */
            margin-bottom: 20px;
            min-height: 50px;
            text-shadow: 0 0 5px #ff6600;
        }
        #score-display, #high-score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.5em;
            color: #00ff00;
            text-shadow: 0 0 5px #000000;
        }
        #high-score-display {
            top: 40px;
        }
        .title { font-size: 3em; color: #00ffff; margin-bottom: 10px; }
        .subtitle { font-size: 1.2em; margin-bottom: 20px; }
        .button {
            background-color: #00ffff;
            color: #0d0d1e;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            margin-top: 15px;
        }
        .button:hover {
            background-color: #00b3b3;
            transform: translateY(-2px);
        }
        .instructions {
            margin-top: 20px;
            font-size: 1.1em;
            color: #cccccc;
        }
        .instructions span {
            color: #ff6600;
            font-weight: bold;
        }

        /* Mobile optimization */
        @media (max-width: 600px) {
            .title { font-size: 2em; }
            #headline-display { font-size: 1.2em; }
            .subtitle { font-size: 1em; }
            .button { font-size: 1em; padding: 10px 20px; }
            .instructions { font-size: 0.9em; }
            #score-display, #high-score-display { font-size: 1em; }
        }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="message-box">
            <div class="title">REAL OR FAKE RUNNER</div>
            <div id="headline-display"></div>
            <div id="status-message" class="subtitle">Press Start to begin.</div>
            <div id="final-score" style="font-size: 2em; margin-bottom: 15px; display: none;"></div>
            <button id="start-button" class="button">Start Game</button>
            // --- 1. HEADLINES DATA ---
// This is the data from the JSON file, embedded directly into the script.
const HEADLINES = [
  { "headline": "A Town in Italy Has Outlawed the Wearing of Flip-Flops.", "isReal": true },
  { "headline": "Scientists Are Training Dogs to Sniff Out Computer Hard Drives.", "isReal": true },
  { "headline": "Finland's Air Force Removed a Swastika from Its Official Emblem.", "isReal": true },
  // ...and so on for all 20 headlines...
];
            <div class="instructions">
                Use **Left Arrow (←)** for **FAKE** news.<br>
                Use **Right Arrow (→)** for **REAL** news.
            </div>
        </div>
    </div>
    <div id="score-display">Score: 0</div>
    <div id="high-score-display">High Score: 0</div>

    <script>
        // --- 1. HEADLINES DATA ---
        // This is the data from the JSON file, embedded directly into the script.
        const HEADLINES = [
          { "headline": "A Town in Italy Has Outlawed the Wearing of Flip-Flops.", "isReal": true },
          { "headline": "Scientists Are Training Dogs to Sniff Out Computer Hard Drives.", "isReal": true },
          { "headline": "Finland's Air Force Removed a Swastika from Its Official Emblem.", "isReal": true },
          { "headline": "A Study Found That Talking to Your Plants Actually Helps Them Grow Faster.", "isReal": true },
          { "headline": "A Man Was Arrested for Trying to Break Into an ATM Machine.", "isReal": true },
          { "headline": "The U.S. Navy Successfully Tested a Laser Weapon That Can Shoot Down Drones.", "isReal": true },
          { "headline": "Engineers Developed a Battery Powered by Snowfall.", "isReal": true },
          { "headline": "Scientists in Russia Claim to Have Discovered the World's Oldest Water.", "isReal": true },
          { "headline": "An Entire City in the Netherlands Is Powered by Cheese Waste.", "isReal": true },
          { "headline": "Norway Once Knighted a King Penguin Named Nils Olav.", "isReal": true },
          { "headline": "SpaceX Announces Plans to Launch a Luxury Hotel into Earth’s Orbit.", "isReal": false },
          { "headline": "New App Uses AI to Translate Your Cat's Meows into Sarcastic Human Speech.", "isReal": false },
          { "headline": "Study Finds That Taking Too Many Selfies Is Linked to a Rare Mental Condition.", "isReal": false },
          { "headline": "A Town in Wyoming Elected a Goat as Its Honorary Mayor.", "isReal": false },
          { "headline": "Scientists Have Designed a New Type of \"Forever\" Plastic That Can Dissolve in Water.", "isReal": false },
          { "headline": "World’s Largest Library Is Now Offering Human Librarians as \"Book Recommendations.\"", "isReal": false },
          { "headline": "Germany Passes a Law Requiring All New Homes to Be Built with Rooftop Gardens.", "isReal": false },
          { "headline": "Google AI Accidentally Creates a New, More Efficient Type of Concrete.", "isReal": false },
          { "headline": "A New York City Restaurant Is Charging $50 to Keep Your Phone Off the Table.", "isReal": false },
          { "headline": "Scientists Discover a New Mineral That Generates Electricity When Exposed to Jazz Music.", "isReal": false }
        ];

        // --- 2. THREE.JS SCENE SETUP ---
        let scene, camera, renderer, player;
        const TILE_WIDTH = 5;
        const TILE_DEPTH = 30;
        const TILE_HEIGHT = 0.5;
        const LANE_WIDTH = 5;
        const LANE_POSITIONS = [-LANE_WIDTH, 0, LANE_WIDTH]; // Left (FAKE), Center, Right (REAL)
        const LANE_MAP = { 0: 'FAKE', 2: 'REAL' };

        let tiles = [];
        let score = 0;
        let isGameOver = false;
        let currentLane = 1; // Start in the middle lane (index 1)
        let playerSpeed = 0.5;
        let headlineQueue = [];
        let nextHeadlineTileZ = -TILE_DEPTH * 3; // Start generating headlines a bit away

        const HEADLINE_ADVANCE_DISTANCE = TILE_DEPTH * 4; // Generate a new headline every 4 tiles
        const TILE_COUNT = 15; // Number of tiles to keep in the scene

        // DOM elements
        const overlay = document.getElementById('overlay');
        const messageBox = document.getElementById('message-box');
        const startButton = document.getElementById('start-button');
        const headlineDisplay = document.getElementById('headline-display');
        const statusMessage = document.getElementById('status-message');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const highScoreDisplay = document.getElementById('high-score-display');

        // Game State
        let currentHeadline = null;
        let isGameRunning = false;
        let isMoving = false; // Player movement flag
        let targetX = 0; // Player target X position
        let moveStartTime = 0;
        const moveDuration = 0.15; // seconds

        // High Score Management
        const HIGH_SCORE_KEY = 'headlineRunnerHighScore';

        function getHighScore() {
            return parseInt(localStorage.getItem(HIGH_SCORE_KEY) || '0', 10);
        }

        function setHighScore(newScore) {
            if (newScore > getHighScore()) {
                localStorage.setItem(HIGH_SCORE_KEY, newScore.toString());
                highScoreDisplay.textContent = `High Score: ${newScore}`;
            }
        }

        // --- 3. CORE GAME FUNCTIONS ---

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0d0d1e, 1, TILE_DEPTH * TILE_COUNT * 0.5);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.rotation.x = -Math.PI / 8; // Look slightly down

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // Player (simple cylinder for visibility)
            const playerGeometry = new THREE.CylinderGeometry(0.7, 0.7, 2, 32);
            const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(LANE_POSITIONS[currentLane], 1.5, 0); // Start at Z=0
            scene.add(player);

            // Load high score
            highScoreDisplay.textContent = `High Score: ${getHighScore()}`;

            // Initialize tiles
            for (let i = 0; i < TILE_COUNT; i++) {
                addTile(i * -TILE_DEPTH);
            }

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            startButton.addEventListener('click', startGame);

            // Start render loop
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            // Reset state
            isGameOver = false;
            isGameRunning = true;
            score = 0;
            currentLane = 1;
            player.position.x = LANE_POSITIONS[currentLane];
            player.position.z = 0;
            playerSpeed = 0.5;
            nextHeadlineTileZ = -TILE_DEPTH * 3;
            headlineQueue = [];
            currentHeadline = null;

            // Clear old tiles and reset
            tiles.forEach(tile => scene.remove(tile));
            tiles = [];
            for (let i = 0; i < TILE_COUNT; i++) {
                addTile(i * -TILE_DEPTH);
            }

            // UI updates
            overlay.style.display = 'none';
            scoreDisplay.textContent = `Score: ${score}`;
            finalScoreDisplay.style.display = 'none';
        }

        function gameOver() {
            if (isGameOver) return;
            isGameOver = true;
            isGameRunning = false;
            setHighScore(score);

            // Show Game Over UI
            overlay.style.display = 'flex';
            statusMessage.textContent = "Game Over! You hit a fake or real wall.";
            headlineDisplay.textContent = "GAME OVER";
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            finalScoreDisplay.style.display = 'block';
            startButton.textContent = "Play Again";
        }

        // --- 4. WORLD GENERATION ---

        function addTile(z) {
            const tileGroup = new THREE.Group();

            // 1. Floor Geometry (3 lanes)
            const floorGeometry = new THREE.BoxGeometry(TILE_WIDTH * 3 + 0.5, TILE_HEIGHT, TILE_DEPTH);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a40 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.set(0, -TILE_HEIGHT / 2, z);
            tileGroup.add(floor);

            // 2. Neon Lane Dividers (Yellow)
            for (let i = 0; i < 2; i++) {
                const dividerGeometry = new THREE.BoxGeometry(0.1, TILE_HEIGHT, TILE_DEPTH);
                const dividerMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                const divider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                divider.position.set(LANE_POSITIONS[i] + LANE_WIDTH / 2, 0, z);
                tileGroup.add(divider);
            }

            // 3. Walls (Simple cylinder walls)
            const wallHeight = 10;
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x2e2e5c });

            // Left Wall
            const leftWallGeometry = new THREE.BoxGeometry(0.5, wallHeight, TILE_DEPTH);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-(TILE_WIDTH * 1.5 + 0.25), wallHeight / 2, z);
            tileGroup.add(leftWall);

            // Right Wall
            const rightWallGeometry = new THREE.BoxGeometry(0.5, wallHeight, TILE_DEPTH);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set((TILE_WIDTH * 1.5 + 0.25), wallHeight / 2, z);
            tileGroup.add(rightWall);

            // 4. Headline Obstacle Generation
            if (z <= nextHeadlineTileZ) {
                spawnHeadlineObstacle(tileGroup, z);
                // Set next spawn point further away
                nextHeadlineTileZ = z - HEADLINE_ADVANCE_DISTANCE;
            }

            // Add tile to scene and array
            tileGroup.position.z = z;
            scene.add(tileGroup);
            tiles.push(tileGroup);
        }

        function spawnHeadlineObstacle(tileGroup, z) {
            // Get a random unique headline
            let availableHeadlines = HEADLINES.filter(h => !headlineQueue.some(q => q.headline.headline === h.headline));
            if (availableHeadlines.length === 0) {
                // If all headlines were used, reset pool
                availableHeadlines = HEADLINES.slice();
            }

            const randomIndex = Math.floor(Math.random() * availableHeadlines.length);
            const headlineData = availableHeadlines[randomIndex];

            // Determine which lane is correct (0=FAKE, 2=REAL)
            const correctLaneIndex = headlineData.isReal ? 2 : 0;
            const correctX = LANE_POSITIONS[correctLaneIndex];

            // Create the obstacle (a large, invisible wall)
            const obstacleGeometry = new THREE.BoxGeometry(TILE_WIDTH * 3, TILE_HEIGHT * 10, 0.5); // Thin barrier
            const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 }); // Invisible
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(0, 0, z + TILE_DEPTH / 2 - 5); // Place it slightly before the end of the tile
            obstacle.userData = { isObstacle: true, isReal: headlineData.isReal, passed: false };

            tileGroup.add(obstacle);

            // Create a "GAP" over the correct lane
            // Block off the INCORRECT lane to force the player into the correct one.
            const incorrectLaneIndex = headlineData.isReal ? 0 : 2;
            const incorrectX = LANE_POSITIONS[incorrectLaneIndex];
            const incorrectLaneBlockerGeometry = new THREE.BoxGeometry(LANE_WIDTH - 0.5, 3, 0.5);
            const incorrectLaneBlockerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const incorrectLaneBlocker = new THREE.Mesh(incorrectLaneBlockerGeometry, incorrectLaneBlockerMaterial);
            incorrectLaneBlocker.position.set(incorrectX, 1.5, obstacle.position.z);
            tileGroup.add(incorrectLaneBlocker);

            // Store the data for player checks
            headlineQueue.push({
                headline: headlineData,
                tile: tileGroup,
                obstacle: obstacle,
                correctLaneIndex: correctLaneIndex,
                passed: false
            });
        }


        // --- 5. GAME LOOP AND UPDATES ---

        function animate(time) {
            requestAnimationFrame(animate);

            if (isGameRunning) {
                const deltaZ = playerSpeed;

                // 1. Move the world (move tiles toward the camera)
                tiles.forEach(tile => {
                    tile.position.z += deltaZ;

                    // Check if tile is behind the camera (needs recycling)
                    if (tile.position.z > camera.position.z) {
                        scene.remove(tile);
                        tiles.shift(); // Remove from front
                        addTile(tiles[tiles.length - 1].position.z - TILE_DEPTH); // Add to back
                        playerSpeed += 0.005; // Increase speed over time
                    }
                });

                // 2. Player Movement Update (Lerp)
                if (isMoving) {
                    const elapsed = (time / 1000) - moveStartTime;
                    const t = Math.min(1, elapsed / moveDuration);
                    player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, t);
                    if (t === 1) {
                        isMoving = false;
                        player.position.x = targetX;
                    }
                }

                // 3. Collision and Scoring Check (Check headlines)
                checkHeadlineCollision(time);
            }

            renderer.render(scene, camera);
        }

        function checkHeadlineCollision(time) {
            // Filter out headlines that have already been passed
            headlineQueue = headlineQueue.filter(h => h.tile.position.z < camera.position.z);

            // Check current headline (the one closest to the player)
            if (headlineQueue.length > 0) {
                const h = headlineQueue[0];

                // a) Display headline
                if (currentHeadline !== h) {
                    currentHeadline = h;
                    headlineDisplay.textContent = h.headline.headline;
                    statusMessage.textContent = h.headline.isReal ? "Is this REAL?" : "Is this FAKE?";
                    // Briefly show the message box for context
                    messageBox.style.opacity = 1;
                    messageBox.style.transition = 'opacity 0.2s';
                }

                // b) Check for passing point (when player reaches the obstacle Z position)
                const obstacleZ = h.tile.position.z + h.obstacle.position.z;

                if (obstacleZ > player.position.z && obstacleZ < player.position.z + deltaZ + 0.1) {
                    // Check if player is in the correct lane
                    const isCorrect = currentLane === h.correctLaneIndex;

                    if (isCorrect) {
                        score++;
                        scoreDisplay.textContent = `Score: ${score}`;
                        // Clear headline display
                        headlineDisplay.textContent = "";
                        statusMessage.textContent = "";
                        messageBox.style.opacity = 0;
                        h.passed = true;
                    } else {
                        // Game Over: Incorrect lane selected
                        gameOver();
                    }
                } else if (obstacleZ > player.position.z + 5 && !h.passed) {
                    // This means the player failed to make a choice in time or missed the gate
                    // This is an implicit game over logic for missing the timing window
                    if (time % 500 < 250) { // Flashing Red Wall
                        // Not strictly necessary due to the red barrier, but good for robust logic
                    }
                }
            } else {
                // If the queue is empty, clear the display
                headlineDisplay.textContent = "";
                statusMessage.textContent = "";
                messageBox.style.opacity = 0;
            }
        }

        // --- 6. INPUT HANDLER ---

        function onKeyDown(event) {
            if (!isGameRunning || isMoving) return;

            let newLane = currentLane;
            let moved = false;

            if (event.key === 'ArrowLeft') {
                newLane = Math.max(0, currentLane - 1); // Move left (towards FAKE lane: 0)
                moved = newLane !== currentLane;
            } else if (event.key === 'ArrowRight') {
                newLane = Math.min(2, currentLane + 1); // Move right (towards REAL lane: 2)
                moved = newLane !== currentLane;
            }

            if (moved) {
                currentLane = newLane;
                targetX = LANE_POSITIONS[currentLane];
                isMoving = true;
                moveStartTime = performance.now() / 1000;
            }
        }


        // --- START APPLICATION ---
        window.onload = function () {
            init();

            // Set initial overlay state
            overlay.style.display = 'flex';
            statusMessage.textContent = "Press Start to begin. Choose Real or Fake to survive!";
            headlineDisplay.textContent = "Welcome to the Runner!";
        };
    </script>
</body>
</html>
